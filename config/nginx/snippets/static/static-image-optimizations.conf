# -------------------------------------------------------------------------------
#      Static Images â€“ Cache forever, serve WebP or Avif if available
# -------------------------------------------------------------------------------

# This requires a `map` directive somewhere globally (http context),
# for example in /etc/nginx/snippets/maps/map-preferred-image.conf :
#
# map $http_accept $preferred_img_ext
# {
#     default        "";
#     "~*image/avif" ".avif";
#     "~*image/webp" ".webp";
# }
#
# This allows NGINX to dynamically serve modern formats if supported by browser.
# Example: if the client requests /image.jpg and supports AVIF,
# NGINX will first try /image.jpg.avif, then /image.jpg.webp, then fallback to /image.jpg.

location ~* \.(?:jpe?g|png|gif|webp|avif|svg|ico)$
{
    # Serve WebP or Avif if available and supported by browser
    try_files $uri$preferred_img_ext $uri =404;

    # Long-term caching (1 year) for versioned images
    add_header Cache-Control "public, immutable, max-age=31536000";

    # Vary header to support content negotiation (e.g., Accept: image/webp)
    add_header Vary Accept;

    access_log off;
    log_not_found off;
}

# ------------------------------------------------------------------------------
#                Block risky SVG if uploaded by users (optional)
# ------------------------------------------------------------------------------

# Even though SVG is a vector image, it can contain scripts or styles,
# so it's recommended to restrict it if users can upload files.

location ~* \.svg$
{
    # Very strict CSP for SVG files to prevent injection (e.g., JS in SVG)
    add_header Content-Security-Policy "default-src 'none'; style-src 'self'; img-src data:;" always;
    add_header X-Content-Type-Options "nosniff";
    add_header X-Frame-Options "DENY";

    try_files $uri =404;

    access_log    off;
    log_not_found off;
}